[{"title":"一个介于wait-free 和 lock-free的高性能MPSC队列","date":"2021-03-04T03:06:13.000Z","path":"2021/03/04/go-mpsc-md/","text":"本文实现了一个介于wait-free 和 lock-free的高性能MPSC队列，也就是多生产者但消费者队列。 与使用channel耗时测试：|测试|MPSC队列耗时| channel耗时 ||–|–|–||测试1| 115.454185ms | 965.9469ms||测试2| 97.00209ms | 992.595ms||测试3| 109.776455ms | 989.837ms||测试4| 90.19232ms | 1.3611857s||测试5| 79.12408ms | 1.2725355s||测试6| 68.650755ms | 1.3981461s||测试7| 77.155775ms | 1.2469043s||测试8| 103.899735ms | 1.4227174s||测试9| 72.15339ms | 1.3351006s||测试10| 129.974485ms | 1.0454128s| package main import ( &quot;fmt&quot; &quot;runtime&quot; &quot;sync&quot; &quot;sync/atomic&quot; &quot;time&quot; &quot;unsafe&quot; ) type TaskNode struct &#123; Data interface&#123;&#125; `json:&quot;data&quot;` Next *TaskNode `json:&quot;Next&quot;` &#125; var UNCONNECTED *TaskNode = new(TaskNode) func NewExecutionQueue(_func func(interface&#123;&#125;)) *ExecutionQueue &#123; return &amp;ExecutionQueue&#123; Head: nil, _execute_func: _func, locker: sync.Mutex&#123;&#125;, pool: &amp;sync.Pool&#123;New: func() interface&#123;&#125; &#123; return new(TaskNode) &#125;&#125;, &#125; &#125; type ExecutionQueue struct &#123; Head *TaskNode `json:&quot;Head&quot;` _execute_func func(interface&#123;&#125;) `json:&quot;-&quot;` // 消费者函数 locker sync.Mutex `json:&quot;-&quot;` pool *sync.Pool `json:&quot;-&quot;` &#125; func (ex *ExecutionQueue) AddTaskNode(data interface&#123;&#125;) &#123; node := ex.pool.Get().(*TaskNode) node.Data = data node.Next = UNCONNECTED preHead := atomic.SwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;ex.Head)), unsafe.Pointer(node)) if preHead != nil &#123; node.Next = (*TaskNode)(preHead) return &#125; node.Next = nil // 任务不多直接执行，防止线程切换 ex._execute_func(node.Data) if !ex.moreTasks(node) &#123; return &#125; go ex.exectueTasks(node) &#125; func (ex *ExecutionQueue) moreTasks(oldNode *TaskNode) bool &#123; newHead := oldNode if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;ex.Head)), unsafe.Pointer(newHead), nil) &#123; return false &#125; newHead = (*TaskNode)(atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;ex.Head)))) var tail *TaskNode p := newHead for &#123; for &#123; if p.Next != UNCONNECTED &#123; break &#125; else &#123; runtime.Gosched() &#125; &#125; saved_next := p.Next p.Next = tail tail = p p = saved_next if p == oldNode &#123; oldNode.Next = tail return true &#125; &#125; &#125; func (ex *ExecutionQueue) exectueTasks(taskNode *TaskNode) &#123; for &#123; tmp := taskNode taskNode = taskNode.Next tmp.Next = nil ex.pool.Put(tmp) ex._execute_func(taskNode.Data) if taskNode.Next == nil &amp;&amp; !ex.moreTasks(taskNode) &#123; return &#125; &#125; &#125; var count int64 = 0 func print(data interface&#123;&#125;) &#123; // a := count // _ = a _ = data.(int) * data.(int) atomic.AddInt64(&amp;count, 1) // fmt.Println(data.(int)) &#125; func Test1() &#123; var singalexit = sync.WaitGroup&#123;&#125; ex := NewExecutionQueue(print) start := time.Now() var s string for k := 0; k &lt; 20; k++ &#123; for i := 0; i &lt; 10000; i++ &#123; singalexit.Add(1) go func(i int, singalexit *sync.WaitGroup) &#123; defer singalexit.Done() for j := 0; j &lt; 90; j++ &#123; ex.AddTaskNode(i*100 + j) &#125; &#125;(i, &amp;singalexit) _ = s &#125; &#125; singalexit.Wait() elapsed := time.Since(start) fmt.Println(&quot;该函数执行完成耗时：&quot;, elapsed/20) time.Sleep(2 * time.Second) fmt.Println(atomic.LoadInt64(&amp;count)) &#125; func Test2() &#123; var singalexit sync.WaitGroup data := make(chan int, 2000) var count1 int64 = 0 go func() &#123; for &#123; &lt;-data atomic.AddInt64(&amp;count1, 1) &#125; &#125;() start := time.Now() func() &#123; for i := 0; i &lt; 10000; i++ &#123; singalexit.Add(1) go func(i int) &#123; defer singalexit.Done() for j := 0; j &lt; 90; j++ &#123; data &lt;- (i*100 + j) &#125; &#125;(i) &#125; &#125;() singalexit.Wait() elapsed := time.Since(start) fmt.Println(&quot;该函数执行完成耗时：&quot;, elapsed) time.Sleep(2 * time.Second) fmt.Println(atomic.LoadInt64(&amp;count1)) &#125; func main() &#123; for i := 0; i &lt; 10; i++ &#123; count = 0 Test1() &#125; for i := 0; i &lt; 10; i++ &#123; Test2() &#125; // Test2() &#125;"},{"title":"Go nil详解","date":"2021-03-04T02:41:36.000Z","path":"2021/03/04/go-nil-type-md/","text":"Go 类型的默认值基本类型（basic type） 内置字符串类型：string. 内置布尔类型：bool. 内置数值类型： int8、uint8（byte）、int16、uint16、int32（rune）、uint32、int64、uint64、int、uint、uintptr。 float32、float64。 complex64、complex128。 注意，byte是uint8的一个内置别名，rune是int32的一个内置别名。 组合类型（composite type）Go支持下列组合类型： 指针类型- 类C指针 结构体类型 - 类C结构体 函数类型 - 函数类型在Go中是一种一等公民类别 容器类型，包括: 数组类型 - 定长容器类型 切片类型 - 动态长度和容量容器类型 映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。 通道类型- 通道用来同步并发的协程 接口类型- 接口在反射和多态中发挥着重要角色 不同类型的默认值 类型 默认值 bool false numbers 0 string &quot;&quot; pointer nil slice nil map nil channel nil function nil interface nil 值得注意的是 struct类型和数组类型零值不是nil。Struct 是各字段值为对应类型的零值，数组类型是各元素类型的零值。且不能将struct类型和数组类型和与nil`进行等值判断，语法校验不通过。 不同类型变量的声明与初始化基本类型声明时就会初始化为默认零值。组合类型则分为声明和初始化两阶段。因此只需要讨论组合类型。统一的理解是，只声明未初始化的组合类型变量都是nil。不过其中还有一些区别，下面一一讲解。 // 声明 var a *int var b *string var c []int var d map[string]string var e chan int var f func() // 初始化 a = make([]int,2) // 声明+初始化 c := make([]int,2) d := make(map[string]string) e := make(chan int) c := []int&#123;1,2,3,4&#125; d := map[string]string&#123;&quot;aaa&quot;:&quot;bbb&quot;&#125; c := &amp;[]int&#123;1,2,3,4&#125; d := &amp;map[string]string&#123;&quot;aaa&quot;:&quot;bbb&quot;&#125; 组合类型nil值nil pointervar w *int //对应汇编 MOVQ $0, &quot;&quot;.w+48(SP) // 此时未初始化。 w为nil if w == nil &#123; fmt.Println(&quot;w is nil&quot;) &#125; 从汇编中可以看到 nil pointer 其实就是指向内存为0的指针。 对指针的操作有两种 取值 *w, 对nil 指针取值会 panic。 调用 nil 指针对应的方法，，可以正常调用 nil sliceslice 分为两部分，一部分是slice本身的结构如下图，其中ptr指向具体元素。 make([]byte, 0) make([]byte, 5) 一般都会区分两个概念，nil slice 和 empty slice nil slice ，其中ptr声明未初始化，为nil。 和nil比较为true empty slice，其中ptr声明并初始化，但是指向空间未分配。和nil比较为false var w []int // 汇编代码 // 设置 ptr 为0 // MOVQ $0, &quot;&quot;.w+112(SP) // XORPS X0, X0 // 设置 len 和 cap 为0 // MOVUPS X0, &quot;&quot;.w+120(SP) w == nil 为 true w1 := make([]int, 0) // 汇编代码，功能同上 // MOVQ AX, &quot;&quot;.w1+88(SP) // XORPS X0, X0 // MOVUPS X0, &quot;&quot;.w1+96(SP) w1 == nil 为 false 从汇编代码能清晰的看到，nil slice和empty slice都初始化了slice结构，只是ptr的值不同。所以 声明一个nil slice后 可以直接使用 nil slice的操作，和empty slice相同： 可以进行 len、cap、 for range、append。注意slice没有删除元素的方法，只能通过在此slice上新建slice来完成 // nil slices var s []int len(s) // 0 cap(s) // 0 for range s // iterates zero times s[i] // panic: index out of range append(s,1) // no eror nil map和上述一样，也有两个概念nil map和empty map map声明后初始化前，此时为nil map map声明后不能进行赋值，只有初始化后才能进行赋值操作，初始化后为empty map var w map[int]string // nil map // 汇编 // MOVQ $0, &quot;&quot;.w+64(SP) w == nil 为 true w1 := map[int]string&#123;&#125; // empty map // 汇编代码太长，省略 w1 == nil 为 false 从汇编中可以发现，nil map仅仅声明了一个指针，并置为nil，而empty map则是声明了对应的数据结构。 因此 nil map在进行赋值操作前，必须初始化，这是与slice的不同点。 nil map和empty map可进行的操作： nil map可进行查找(查找任意值会返回数据类型的默认值)、删除、len和range操作，并不会报错 。但是不能进行赋值操作，必须初始化。 empty map, 可进行map所有操作。 只声明一个map类型变量时，为nil map 此时为只读map，无法进行写操作，否则会触发panic map 构建分两步， map声明后初始化前，可进行查找、删除、len和range操作，并不会报错 ，此时为nil map map声明后不能进行赋值，只有初始化后才能进行赋值操作，初始化后为empty map nil map和empty map区别： nil map：只声明未初始化，此时为只读map，不能写入操作，示例：var m map[t]v empty map：空map，已初始化，可写入，示例：m := map[t]v&#123;&#125;或m := make(map[string]string, 0) // nil maps var m map[t]u // nil map m2 := map[t]u&#123;&#125; // empty map len(m) // 0 for range m // iterates zero times v, ok := m[i] // zero(u), false m[i] = x // panic: assignment to entry in nil map nil channelvar w chan int // nil chan // 汇编代码 // MOVQ $0, &quot;&quot;.w+56(SP) w1 := make(chan int) // 汇编代码 // LEAQ type.chan int(SB), AX // MOVQ AX, (SP) // MOVQ $0, 8(SP) // PCDATA $1, $1 // CALL runtime.makechan(SB) // MOVQ 16(SP), AX // MOVQ AX, &quot;&quot;.w1+48(SP) 从汇编可以看到 channel 也需要声明和初始化。nil chan 仅仅只是创建了一个为nil指针，初始化才会创建具体的结构体。 nil chan 的操作: 读 写 都会无限阻塞 close 会发生panic // nil channels var c chan t &lt;- c // blocks forever c &lt;- x // blocks forever close(c) // panic: close of nil channel nil funcmap、channel、function的本质都是指向具体实现的指针，而对应类型的nil则是不指向任何地址。因此不做具体介绍 nil interfaceinterface底层由两部分组成：类型、值(type, value)，当二者均为nil时，此时interface才为nil。 var w io.Reader 此时为(nil,nil) // 汇编 // XORPS X0, X0 // MOVUPS X0, &quot;&quot;.w+40(SP) w == nil // true var a *strings.Reader 此时为(*strings.Reader,nil) w = a // 汇编 MOVQ $0, &quot;&quot;..autotmp_2+32(SP) LEAQ go.itab.*strings.Reader,io.Reader(SB), AX MOVQ AX, &quot;&quot;.w+40(SP) // _type 为 *strings.Reader MOVQ $0, &quot;&quot;.w+48(SP) // datac 为 nil w = strings.NewReader(&quot;1234&quot;) 此时为(*strings.Reader, 对应数据地址) // 汇编 LEAQ go.string.&quot;1234&quot;(SB), AX MOVQ AX, (SP) MOVQ $4, 8(SP) PCDATA $1, $0 CALL strings.NewReader(SB) MOVQ 16(SP), AX //strings.NewReader(SB) 返回的地址 放入 AX MOVQ AX, &quot;&quot;..autotmp_1+32(SP) LEAQ go.itab.*strings.Reader,io.Reader(SB), CX MOVQ CX, &quot;&quot;.w+40(SP) // _type 为 *strings.Reader MOVQ AX, &quot;&quot;.w+48(SP) // datac 为 strings.NewReader(SB) 返回的地址 var s Write // Write 此时 s 为nil，为一个纯接口 var p *Person // nil of type *Person var s Write = p // 赋值后，s 带有了p的类型信息，但是 p 为nil，所以值为nil 有可得，当interface 为 nil时，变量为一个nil的指针；当不为nil值时，会实例化为下面一种结构体。 type eface struct &#123; // 16 字节 不包含任何方法的接口 _type *_type data unsafe.Pointer &#125; type iface struct &#123; // 16 字节 包含方法的接口 tab *itab data unsafe.Pointer &#125; 不要返回具体的错误类型，而应直接返回nil下面展示返回类型为interface时的差异： 错误示例： func do() error &#123; // error(*doError, nil) var err *doError return err // nil of type *doError &#125; func main() &#123; err := do() // error(*doError, nil) fmt.Println(err == nil) // false &#125; 正确示例： func do() *doError &#123; // nil of type *doError return nil &#125; func main() &#123; err := do() // nil of type *doError fmt.Println(err == nil) // true &#125; 再看下面这段代码，虽然do()返回nil，但wrapDo()返回依然是接口，也就是类型为*doError，值为nil的接口，此时拿到的返回值并不等于nil。 func do() *doError &#123; // nil of type *doError return nil &#125; func wrapDo() error &#123; // error (*doError, nil) return do() // nil of type *doError &#125; func main() &#123; err := wrapDo() // error (*doError, nil) fmt.Println(err == nil) // false &#125; nil的有效利用 nil类型接收者是可以正确调用方法的 nil reveivers are userful Keep nil (pointer) useful if possible, if not NewX() Use nil slices, they&#39;re often fast enough Use nil maps as read-only empty maps，将nil map作为只读的空map（不能读nil map进行写入操作，否则会发生panic） Use nil channel to disable a select case，nil channel来阻塞selct/case语句 nil value can satisfy interface，不同类型的nil值可满足interface，也就是可赋值给interface Use nil interface to signal defaul，使用nil的interface来标识使用缺省处理 nil的一些常见用法nil pointer用法 nil pointer用来和nil比较确认是否为零值 var p *int p == nil // true *p // panic: runtime error: invalid memory address or nil pointer dereference 来看看，如何实现二叉树树的求和操作： type tree &#123; v int l *tree r *tree &#125; func (t *tree) Sum() int 第一种方案，有两个问题： 代码冗余，重复的if v != nil &#123;v.m()&#125; 当t为nil时，会发生panic var t *tree // nil of type *tree sum := t.Sum() // panic // 实现方案1 func (t *tree) Sum() int &#123; sum := t.v if t.l != nil &#123; sum += t.l.Sum() &#125; if t.r != nil &#123; sum += t.r.Sum() &#125; return sum &#125; nil接收者，也可以正确调用方法，所以可以利用这一点，改造出方案2： // 方案2：代码简洁、可断性提高很多 func (t *tree) Sum() int &#123; if t == nil &#123; return 0 &#125; return v + t.l.Sum() + t.r.Sum() &#125; 通过利用类型的nil，可以灵活实现是否为空的处理，已经便捷实现扩展函数： func (t *tree) String() string &#123; if t == nil &#123; return &quot;&quot; &#125; return fmt.Sprint(t.l, t.v, t.r) &#125; func (t *tree) Find(v int) bool &#123; if t == nil &#123; return false &#125; return t.v go== v || t.l.Find(v) || t.r.Find(v) &#125; nil slices用法 不能对nil slice进行取值，否则会发生panic 可通过append函数对nil slice进行增加元素操作 var s []int len(s) // 0 cap(s) // 0 for range s // 执行0次 s[i] // panic: index out of range for i := 0; i &lt;10; i++ &#123; fmt.Printf(&quot;len: %2d, cap: %2d\\n&quot;, len(s), cap(s)) s = append(s, i) &#125; nil map用法 nil map不能进行增加元素操作，因它还没有进行初始化 将nil map作为只读的空map var m map[t]u len(m) // 0 for range m // 执行0次 v, ok := m[i] // v=zero(u), ok=false m[i] = x // panic: assignment to entry in nil map // 有个nil map有用的例子 func NewGet(url string, headers map[string]string)(*http.Request, error) &#123; req, err := http.NewRequest(http.MethodGet, url, nil) if err != nil &#123; return nil, err &#125; for k, v := range headers &#123; req.Header.Set(k, v) &#125; return req, nil &#125; // 调用时，传递headers NewGet( &quot;http://google.com&quot;, map[string]string&#123; &quot;USER_AGENT&quot;:&quot;google/gopher&quot;, &#125;, // go语言五十度灰，如果参数和)之间换行形式，参数尾部需追加,逗号 ) // 调用时，不传递headers，可以传递一个empty map空map NewGet( &quot;http://google.com&quot;, map[string]string&#123;&#125;, // 传递空map，empty map ) // 调用时，不传递headers，可以传递一个nil map NewGet( &quot;http://google.com&quot;, nil, // 传递nil map，也是合法的 ) nil channel用法 不能对nil channel进行close()操作，发触发panic: close of nil channel 不能对channel进行多次close，会触发 panic: close of closed channel 关闭channel，在select/case中将依然能获取到值，但nil channel将阻塞读操作来失效select/case中逻辑 var c chan t // nil of type chan t // nil channel操作时 &lt;- c // block forever，持续阻塞 c &lt;- x // block forever，持续阻塞 close(c) // panic: close of nil channel，关闭nil channel发生panic // 对于已关闭的channel，将发生如下现象 v := &lt;- c //closed channel是可以被消费者继续读取的，在读完了有意义的数据之后，将读到一堆空值。比如这里的int类型就是0。 v, ok := &lt;-c // zero(t), false 不会阻塞，返回零值和False c &lt;-x // panic: send to close channel close(x) // panic: close of closed channel，备注原文中错误 现在假设要实现一个合并函数，实现从两个通道中获取数据，然后写入out输出通道： func merge(out chan&lt;- int, a,b &lt;-chan int) &#123; for &#123; select &#123; case v:= &lt;-a: // 当a/b通道关闭时，这里将持续获取到0 out &lt;-v case v:= &lt;-b out &lt;-v &#125; &#125; &#125; 改造代码后如下： func merge(out chan&lt;- int, a,b &lt;-chan int) &#123; var aClosed, bClosed bool for !aClosed || !bClosed &#123; select &#123; case v,ok := &lt;-a: // 此时通道关闭后，就不会再进行获取了 if !ok &#123; aClosed = true fmt.Println(&quot;a is closed&quot;) continue &#125; out &lt;-v case v,ok := &lt;-b: if !ok &#123; bClosed = true fmt.Println(&quot;b is closed&quot;) continue &#125; out &lt;-v &#125; &#125; close(out) // 需要在不使用后进行close操作 &#125; 终于搞定了，提交代码，转交给测试吧！你会发现“a is closed” 和 “b is closed”可能会执行多次，为什么？因为外部逻辑如果关闭了a/b，此时还能够读取。此时上述代码中会有空转的逻辑，运行下，看看打印输出： a is closed a is closed a is closed a is closed a is closed // 很多次无用的空转逻辑 b is closed // 最后一次，a/b都未空时才结束循环 可能看到这里已经有些蒙了，但要明白，无论是否关闭一个chanel，都可以从中读取到值，而如果不需要对channel取值操作了，那么可以将其改为nil，这样会永远阻塞读，防止再发生读操作；同时应在入口增加非nil判断。 func merge(out chan&lt;- int, a, b &lt;-chan int) &#123; for a != nil || b != nil &#123; select &#123; case v, ok := &lt;-a: // 此时通道关闭后，a == nil，在读取会永远阻塞 if !ok &#123; a = nil fmt.Println(&quot;a is closed&quot;) continue &#125; out &lt;- v case v, ok := &lt;-b: if !ok &#123; b = nil fmt.Println(&quot;b is closed&quot;) continue &#125; out &lt;- v &#125; &#125; close(out) // 需要再不使用后进行close操作 &#125; nil func用法 go中函数是一等公民 函数可以作为struct结构体的字段，缺省值则为nil type Foo struct &#123; f func() error // f is type of func() error &#125; // 常见用法，传输函数为nil，增加缺省处理 func NewServer(logger func(string, ...interface&#123;&#125;)) &#123; if logger == nil &#123; logger = log.Printf &#125; logger.Printf(&quot;initializng %s&quot;, os.Getenv(&quot;hostname&quot;)) &#125; nil interface用法 将nil interface作为一种信号来使用 nil指针，不等于nil接口 if err != nil &#123; ... &#125; type Summer interface &#123; Sum() int &#125; var t *tree // nil of type *tree var s Summer = t // nil指针，可以是合法的interface类型的值 // 此时，对接接口类型变量s而言，其类型为*tree，值为nil，也就是说(*tree, nil)行的interface fmt.Println(t==nil, s.Sum()) // true, 0 type ints []int func (i ints) Sum() int &#123; s := 0 for _, v := range i&#123; s += v &#125; return s &#125; var i ints var s Summer = i // summer 为([]int,i) fmt.Println(s==nil, s.Sum()) // false, 0 // 通过判断接口为nil，来给定缺省值 func doSum(s Summer) int &#123; if s == nil &#123; return 0 &#125; return s.Sum() &#125; var t *tree doSum(t) // interface的类型和值分别为：(*tree, nil) var i ints doSum(i) // (ints, nil) doSum(nil) // (nil, nil) http.HandleFunc(&quot;localhost:8080&quot;, nil) // 传递nil，则使用缺省处理 参考阅读 理解Golang中的 nil | 小武的博客 (fivezh.github.io)"},{"title":"hello world","date":"2021-02-27T16:06:07.506Z","path":"2021/02/28/hello-world/","text":"一直想写博客，断断续续零散也糊弄了几篇，却未坚持下去，望这次能坚持下去！ 如果您对本文有问题，评论，或建议，请访问GitHub Discussion board,这是一个Github讨论版，使用它可以进行更方便的交流。"},{"title":"Go 实际项目测试实践","date":"2021-02-21T16:50:58.000Z","path":"2021/02/22/Go-Test-Used/","text":"测试的重要性不言而喻。然而在项目中，真正做到编写完整的测试却是少之又少。 主要原因推测有三个： 觉得写测试太麻烦，花费时间。其实我觉得这是个伪命题，因为通常写完一段代码，我们肯定会测试该代码能否正确执行，比如HTTP请求，数据库请求，RPC请求，逻辑函数。我们都会进行访问测试，这其实就是测试用例了，只是没有集成到测试框架中。其实，我们完全可以将这部分测试写成代码放到测试中。 代码不可测试。这其实很常见，大部分我们都是接手已有的代码。如果代码没有好的架构设计，统一的分格，强制的CR。那么写出不可测试的代码也就司空见惯了。对于这种代码，只能进行逐步重构了。 不知道怎么测试。项目中的代码一般都会有很多的依赖，而测试中去独立部署这些服务肯定成本巨大，因此如何处理这些依赖是建立测试的最大障碍。下文中我也会尝试介绍这部分的处理手段。 一般的测试分为单元测试和集成测试，但是这里我们会模糊这种界限，不做具体区分。下面出现的代码都是为了这篇文章而写的伪代码，没有考虑架构之类的。 项目基本介绍为了结合项目介绍测试的方法，在这里，我简单实现了一个基本的业务逻辑框架。分为API层、Service层，基础依赖层有数据库（也就是DAO层）、缓存层（一般也就是Redis）、RPC等。简单代码函数如下： // Service 为业务领域。经常变动大，因此不做接口 type PostService struct&#123; // Service 通过属性保存用到的基础依赖，通过依赖注入进行解藕，一能灵活改变扩展，二也方便测试MOCK // PostDAO 和 RedisClient 皆为接口，变动会很小。 postDAO *PostDAO // 数据库依赖，后面会细讲 cacheClient *CacheClient // 缓存层依赖，后面会细讲 &#125; // 依赖注入，也叫控制反转， func NewPostService(postDAO *PostDAO, redisClient *RedisClient) &#123; return &amp;PostService&#123; postDAO: postDAO, cacheClient: cacheClient, &#125; &#125; // 具体的业务接口 func (post *PostService)GetAllPost() &#123; ... 业务逻辑 post.postDAO.FindPosts() .... &#125; // API层（也可叫Controller层） type Server struct&#123; // go 中 http服务器对象 ln net.Listener server *http.Server // 对应的 Service 逻辑，启动应用时实例化 postService *PostService &#125; func NewServer(ln net.Listener, server *http.Server ) &#123; return &amp;Server&#123; ln: ln, server: server, &#125; &#125; // 依赖注入 PostService func (server *Server)SetPostService(postDAO *PostDAO, redisClient *RedisClient) &#123; server.postService = NewPostService(postDAO, redisClient) &#125; // API func (server *Server)GetPosts(w http.ResponseWriter, r *http.Request) &#123; ... 请求参数检查 server.postService.GetAllPost() ... 返回响应信息 &#125; 上面的设计算是一种 领域驱动设计（DDD）（其实和MVC等传统的分层差不了太多），业务逻辑层和所有的其他层进行了解藕，更换底层的数据库，缓存层时，不需要改变业务逻辑代码。常见的架构拆分有模块拆分 和分层拆分，这里不做扩展，简单提供个小经验。大项目可以模块拆分，小项目分层拆分就行，另外由于Go的循环引用限制，大多数情况下分层拆分更好，具体可看 翻译Packages as layers, not groups。 上述业务架构机会适合大部分项目，根据代码我们可以将测试分为三部分：一是API层测试；二是Service测试；三是依赖层测试。 虽然访问是从API到依赖层，但是测试中首先要讲解的便是依赖层。 基础依赖层测试基础依赖层即好测试又不好测试，好测试是应为依赖层不会在依赖其他层，同时代码变动不大，开发完成几乎不会变动。不好测试是因为基础依赖机会都需要开启另一个服务，比如MySQL，Redis同时还的进行初始化。 DAO 数据库依赖层测试测试的基础是DAO层需要解藕，也就是得建立对应的接口文件（由于基层依赖层变动少，因此接口必须仔细设计好，翻译Common CRUD Design in Go可以参考），同时进行依赖反转。虽然在Go中不通过接口也能去直接MOCK对应函数，但是极不推荐，本文也不会做详细说明。 DAO层主要是进行数据库中的表格增删改查的操作。下面实现上述代码的PostDAO接口。 // 接口文件 type PostDAO interface &#123; FindPostByID(ctx context.Context, id int) (*Post, error) FindPosts(ctx context.Context, filter PostFilter) ([]*Post, int, error) CreatePost(ctx context.Context, post *Post) error UpdatePost(ctx context.Context, id int, upd PostUpdate) (*Post, error) DeletePost(ctx context.Context, id int) error &#125; // 对应的实现 type PostMysql struct&#123; db *sql.DB &#125; // 依赖注入 sql.DB func NewPostMysql(db *sql.DB)&#123; return &amp;PostMysql&#123; db: db, &#125; &#125; func (s *PostMysql) FindPostByID(ctx context.Context, id int) (*Post, error)&#123; ... &#125; func (s *PostMysql) FindPosts(ctx context.Context, filter PostFilter) ([]*Post, int, error)&#123; s.db.Exec(&quot;...&quot;,...) &#125; func (s *PostMysql) CreatePost(ctx context.Context, post *Post) error&#123; ... &#125; func (s *PostMysql) UpdatePost(ctx context.Context, id int, upd PostUpdate) (*Post, error)&#123; ... &#125; func (s *PostMysql) DeletePost(ctx context.Context, id int) error &#123; ... &#125; DAO层测试有一个重要的问题值得讨论：应不应该建一个数据库进行测试。建立数据库能最好的模拟真实环境，但是成本巨大。不建立进行Mock（这里的Mock是只mock掉DB数据库，而不是DAO这层）的话，也有问题，一是未在真实环境中进行测试，难免会有问题，而是mock掉一个数据成本不必建立一个数据库大。在这里，我是推荐建立真实数据库的，传统建立数据库麻烦，但是幸好，我们又Docker 和 docker-compose （还不知道docker的可以退群了）。一共三种方案依次介绍 建立真实数据库，测试最方便。直接上docker-compose.yml代码。通过docker-compose 我们可以一条命令启动我们的测试环境，并且用完就可以删除容器。完美无害```ymlversion: “3.9” services: mysql: networks: - mysql_net image: mysql:5.7.29 restart: always command: –default-authentication-plugin=mysql_native_password environment: MYSQL_ROOT_PASSWORD: test123 ports: - 3306:3306 volumes: # mysql 初始化脚本目录，可以将init.sql放入该目录，容器初始化时会自动执行。 - “./docker/init_sql:/docker-entrypoint-initdb.d/“ # 查看mysql 工具，网页访问 8080 可查看数据库内容。 adminer: networks: - mysql_net image: adminer restart: always ports: - 8080:8080 networks: mysql_net: name: mysql_net driver: bridge 测试代码 ```go func TestPostMysql(t *testing.T) &#123; // 连接 docker 数据库 conn_str := &quot;root:test123@tcp(localhost:3306)/dataname?autocommit=1&amp;timeout=200ms&amp;readTimeout=2s&amp;writeTimeout=2s&quot; db, err := sql.Open(&quot;mysql&quot;,conn_str) if err != nil &#123; log.Fatal(err) &#125; defer db.Close() postMysql := NewPostMysql(db) // 使用了Convey 框架 convey.Convey(&quot;PostMysql 测试&quot;,t, func() &#123; post := &amp;Post&#123; ... &#125; convey.Convey(&quot;添加-&gt;查找-&gt;删除测试&quot;, func() &#123; convey.Convey(&quot;添加数据&quot;, func() &#123; postNew := post err := postMysql.CreatePost(context.Background(), postNew) convey.So(err, convey.ShouldEqual, nil) convey.Convey(&quot;查找&quot;, func() &#123; res, err :=postMysql.FindPostByID(context.Background(),postNew.PostId) convey.So(err,convey.ShouldEqual,nil) convey.So(*res,convey.ShouldResemble,postNew) convey.Convey(&quot;删除&quot;, func() &#123; err = postMysql.DeletePost(context.Background(),postNew.PostId) convey.So(err, convey.ShouldEqual, nil) convey.Convey(&quot;再查找试试&quot;, func() &#123; _, err :=postMysql.FindPostByID(context.Background(),postNew.PostId) convey.So(err,convey.ShouldBeError) &#125;) &#125;) &#125;) &#125;) &#125;) &#125; 测试代码例子， docker-compose.yml都给出来了，相信大家都能看懂，也就不多说了。2. 第二种方法是用内存数据库，在Java中有h2内存数据库，不见建立第三方服务，且兼容大部分Mysql语法。在Go里面，由于 database/sql是一个接口层，因此，我们可以采用Sqlite的驱动实例化一个sql.DB出来，但是还是会有兼容问题，因此极不推荐。使用在上述代码中改个驱动就行了，也就不详细说明了。3. 第三种方法是Go独有的，也是因为database/sql是一个接口层，有一个包go-sqlmock，其实和第二种也是一样的，只是需要自己模拟输入输出，具体可以看官网用法。也不推荐。 缓存层、RPC层等基础依赖在应用中缓存层是少不了的。现在的缓存大部分都是Redis，类似一个内存数据库，因此测试方法和上述一样，推荐在Docker中真实的建立一个Redis服务，如果实在不能建立，可以考虑使用 miniredis项目，和上述DAO中的第二种方法类似，模拟了一个小的Redis，兼容大部分常见命令。 在这里值得说的是RPC等依赖。在微服务中，一个服务调用多个服务是很常见的情况。而这些服务我们又不可能在本地建立一个真实的环境。因此只能想办法去Mock掉。方法也很简单，就是根据服务提供的API抽象出一个接口文件，然后使用适配器模式或代理模式进行Wrap一层。 Service层测试Sevice层通常是业务逻辑的地方，这里的测试容易与否主要看基础依赖层和Service是否完全解藕，如果解藕，Service层的测试将会变得非常容易。 这里也有一个问题，是否要对基础依赖层进行Mock，有人可能问，不Mock的话直接设计接口这一套是干嘛呢，不如直接搭建环境。这里的主要不Mock的原因是我们想尽量真实的模拟线上环境。而且有些基础设计是只能Mock的。同时，这里可以不Mock的另一个前提是，我们的解藕做的很好，同时基层依赖层的测试也做的很好。不然的话我们只能进行Mock了。 常用的Mock工具是 go-mock具体用法不多介绍了，可以直接看文档。我简单说下，我的做法，由于解藕做的很好，所以我的测试实现中会自动判断是否数据库能连接成功，如何可以的话用数据库实例的基础依赖层测试，否则用go-mock生成的基础依赖层进行测试。具体代码如下 func TestGetAllPost(t1 *testing.T) &#123; postDAO,issql:= GetPostDAO(t1) if !issql &#123; ... mock 配置 &#125; // redisClient 的获取方法一样，不写代码 edisClient,isTrue:= GetRedisClient(t) if !isTrue &#123; ... mock 初使化 &#125; postService := NewPostService(postDAO, redisClient) Convey(&quot;TestGetAllPost&quot;, t1, func() &#123; postServie.GetAllPost() ... &#125;) &#125; func GetPostDAO(t1 *testing.T) (PostDao,bool)&#123; conn_str := &quot;root:test123@tcp(localhost:3306)/rule?autocommit=1&amp;timeout=200ms&amp;readTimeout=2s&amp;writeTimeout=2s&quot; db, err := sql.Open(&quot;mysql&quot;,conn_str) if err != nil &#123; log.Fatal(err) &#125; if err := conn.Ping(); err != nil &#123; return nil,false &#125; if falg &#123; t1.Log(&quot;数据库开启，使用数据库进行测试&quot;) return NewPostMysql(db),true &#125;else &#123; t1.Log(&quot;数据库未开启，使用MOCK DAO层测试&quot;) ctl := gomock.NewController(t1) defer ctl.Finish() PostDaoMock := mock.NewMockPostDao(ctl) //TemplateId := 123456 //MustMockCreateTemplate(templateDaoMock,TemplateId) return PostDao,false &#125; &#125; API层测试API层测试可以说是集成测试了，一般开发人员开发后，测试人员主要会对这部分接口进行测试。而且这部分测试一般都需要建立HTTP请求，因此耗时费力，开发人员大部分只会进行简单的访问看看能够跑通。然而Go给我们提供了方便的http测试工具，使用这些工具不但能方便测试，还能保存复用，不必每次在浏览器测试。下面代码举个例子。 func setupServerPostHandler(t *testing.T) *gin.Engine &#123; engine := gin.New() //engine.Use(middleware.Logger()) engine.Use(gin.Recovery()) PostDaoMock,issql:= GetPostDAO(t) if !issql &#123; ... mock 初使化 &#125; RedisClient,isTrue:= GetRedisClient(t) if !isTrue &#123; ... mock 初使化 &#125; server := NewServer() // 唯一依赖 server.SetPostService(PostDaoMock,RedisClient) engine.POST(&quot;/AddPost&quot;, server.GetPosts) return engine &#125; func TestPostHandler(t *testing.T) &#123; router := setupServerPostHandler(t) Convey(&quot;Post Handler接口测试&quot;,t, func() &#123; req_content := &amp;Post&#123; ... 内容 &#125; type Data_resp struct &#123; Post_id int `json:Post_id` &#125; type resp_json struct &#123; Data Data_resp `json:data` Err_msg string `json:err_msg` Err_no int `json:err_no` &#125; req_content.Type = &quot;AddPost&quot; Convey(&quot;AddPost 测试&quot;, func() &#123; Convey(&quot;AddPost 测试1&quot;, func() &#123; req_new := req_content req_string, _ := json.Marshal(req_new) req := httptest.NewRequest(http.MethodPost, &quot;/AddPost&quot;, strings.NewReader(string(req_string))) req.Header[global.HEADER_TRACEID] = []string&#123;&quot;testTrace&quot;&#125; req.Header[global.HEADER_SPANID] = []string&#123;&quot;testSpan&quot;&#125; req.Header[global.HEADER_USER] = []string&#123;&quot;testUser&quot;&#125; req.Header.Set(&quot;Content-Type&quot;,&quot;application/json&quot;) w := httptest.NewRecorder() router.ServeHTTP(w, req) resp := w.Result() resp_json1 := &amp;resp_json&#123;&#125; _ = json.Unmarshal(w.Body.Bytes(), resp_json1) So(resp_json1.Data.Post_id,ShouldHaveSameTypeAs,1) So(resp.StatusCode,ShouldEqual,http.StatusOK) &#125;) &#125;) &#125;) &#125; 相信代码已经足够清晰，因此不在赘述。 一些测试问题多个函数调用如何写测试通常函数直接是相互调用的，比如API层调用Service层，接着调用基础服务层。一个请求在多个函数中经过。这种情况各个测试的侧重点如何写呢。 有个简单做法，各自函数着重测试自己的实现逻辑。比如一般在API层，我们会进行参数检测，那在这一步我们就着重测试参数检测的测试用例。而在Service，此时我们只需要提供正确的参数就行，不必在提供错误的请求参数。而在基础依赖层，我们也就不必测试ID小于0，或参数类型，范围的错误用例了。 有状态函数如何测试什么叫有状态函数，这里简单顶一下，函数中出现的可变变量不是由参数传递的。比如函数中如果用了全局变量，类的中局部属性，时间函数，随机数生成器，那么这些就都是有状态的，在不同时间、环境下，相同的输入会有不同的输出。当然也有一些情况例外，比如上述中DAO中的sql.DB一般初始化后就不会改变，这种就不算有状态函数了。 这些函数在测试之前，我们必须固定其中的参数，常见的语言中，你必须将这些方法单独提取出来，进行封装。然而在Go中，你可以使用monkey 包直接在运行时替换掉原函数。该库为github.com/agiledragon/gomonkey，具体用法可以查看官方文档。 无法mock的依赖一些项目由于历史原因，无法解藕，这部分代码，如果非要测试，也只有使用上述的monkey直接替换原函数。 总结给一个函数写测试其实并不难，但是给一个大项目写测试需要一定的架构设计能力，首先的理解项目的架构，然后才能围绕项目设计一个测试的架构。大部分人化时间去学习MVC，分层等架构，但是很少会有些去学习测试框架的架构。而者也是大部分人面对一个项目不知道如何去写测试的主要原因。希望这篇文章能给大家一点收获。 另外，测试也是不断集成的，我们不可能使用测试一下子就测试到所有情况，因此在线上环境发现 bug 时，需要及时补充我们的测试。这样，不断集成测试用例后，后续开发时，就真正只需要测试一下，就可以放心的提交上线。"},{"title":"[翻译]Real-world SQL in Go: PartI","date":"2021-01-27T13:38:52.000Z","path":"2021/01/27/Real-world-SQL-in-Go-Part-I/","text":"原文由 Ben Johnson 发表在 gobeyond，推荐观看原文文章链接 不管您是不是讨厌还是接受SQL，在某个时候您都会在项目中使用它。关系数据库结构并不总是能很好地映射到应用程序数据结构，但SQL的普遍性意味着它是开发人员在需要数据持久性时使用的基本工具。 虽然Go有GORM之类的对象关系映射库，但我们将避免这种集成库，而直接使用标准库包database/sql。ORM库封装了SQL底层的复杂性，在简单的数据访问中这很有帮助，但缺点是会使高级查询和调试更加复杂。 在本文中，我们将研究如何直接使用SQL构造数据访问代码、在何处处理业务模型以及一些有用的SQL技巧。我将引用WTF Dial项目的代码。你可以通过这篇介绍性的博客文章来了解它。 实现服务接口在上一篇关于CRUD设计的博客文章中，我描述了一个用于管理实体(entity)的接口。一个dial是衡量当前用户对自己所属团队的感到沮丧指标。同时该团队中其他成员也有对应的dial指标。 // dial.go#L81-L122 type DialService interface &#123; FindDialByID(ctx context.Context, id int) (*Dial, error) FindDials(ctx context.Context, filter DialFilter) ([]*Dial, int, error) CreateDial(ctx context.Context, dial *Dial) error UpdateDial(ctx context.Context, id int, upd DialUpdate) (*Dial, error) DeleteDial(ctx context.Context, id int) error &#125; 这里我们使用SQLite作为我们的数据库。但是在这里讨论的概念适用于任何SQL数据库。 主要包含三个包wtf.DialService，sqlite，sqlite.DialService。 封装数据库将我们的包命名为通用的名字(比如sqlite)似乎有些奇怪，但我们的包将封装底层的其他包，而不会暴露这些包的内部。我们包的调用者只能通过我们的包与SQL和SQLite交互。你命名为sqlite database/sql mattn/go-sqlite3 wtfsqlite wtfsql，但我个人觉得丑陋。 因为我们没有公开底层的SQL包，所以在我们的应用程序中提供自己的封装包类型：DB sqlite // sqlite/sqlite.go#L43-L58 // DB represents a database connection to our application. type DB struct &#123; db *sql.DB // Datasource name. DSN string &#125; // Open opens the database connection. func (db *DB) Open() (err error) // Close closes the database connection. func (db *DB) Close() error 这种封装让我们可以在我们的方法中处理数据库的启动和关闭，而不需要关心底层数据库Open() 的Close()的细节. 从SQL helpers 中分离接口实现在我的包中，我发现解藕服务接口实现和实际执行SQL的函数很有用。服务实现存在于原因： 提供接口wtf.DialService 的一个实现。 提供业务边界。 因此，服务方法通常很小，并且采用以下格式： // sqlite/dial.go#L75-L99 func (s *DialService) CreateDial(ctx context.Context, dial *wtf.Dial) error &#123; tx, err := s.db.BeginTx(ctx, nil) if err != nil &#123; return err &#125; defer tx.Rollback() // Call helper functions... return tx.Commit() &#125; 在本例中，我们启动一个事务，执行一些较低级别的SQL helpers函数，然后提交。如果SQL helpers函数中发生任何错误，那么进行回滚放弃更改。如果我们的函数到达末尾并成功调用，那么提交事务保存更改, defer tx.Rollback()将不做操作. 一个典型的 helper function如下 // sqlite/dial.go#L360-L418 func createDial(ctx context.Context, tx *Tx, dial *wtf.Dial) error helper函数是通用性的函数，它们不附加到特定的服务。因此它们可以被不同的服务使用，甚至可以被其他helper函数调用。这是一种封装低级SQL调用,提供抽象的高级函数的简单方法。 实现实体查询我们的 wtf.DialService包中定义了 FindDials()一个用于搜索Dial的接口。 // dial.go#L81-L122 package wtf type DialService interface &#123; FindDials(ctx context.Context, filter DialFilter) ([]*Dial, int, error) ... &#125; 服务具体实现这个接口的具体实现在我们的包sqlite中: // sqlite/dial.go#L47-L73 func (s *DialService) FindDials(ctx context.Context, filter wtf.DialFilter) ([]*wtf.Dial, int, error) &#123; tx, err := s.db.BeginTx(ctx, nil) if err != nil &#123; return nil, 0, err &#125; defer tx.Rollback() // 调用helper类 // Fetch list of matching dial objects. dials, n, err := findDials(ctx, tx, filter) if err != nil &#123; return dials, n, err &#125; // Iterate over dials and attach associated owner user. // This should be batched up if using a remote database server. for _, dial := range dials &#123; if err := attachDialAssociations(ctx, tx, dial); err != nil &#123; return dials, n, err &#125; &#125; return dials, n, nil &#125; 从较高的层次来看，它执行三个步骤： 建立业务边界。 查找匹配的 dial。 查找每个dial的关联数据（例如dial所有者）。 Helper methods我们有一个用于搜索的helper方法，因为我们希望将其用于其他服务。例如，在查找用户时，我们可能还希望返回该用户的dial 列表。 我们的helper方法从较高的层次来看如下： // sqlite/dial.go#L292-L358 // helper 方法, 和上文中的方法不一样,不属于DialService结构体 func findDials(ctx context.Context, tx *Tx, filter wtf.DialFilter) ([]*wtf.Dial, int, error) &#123; // Build WHERE clause... // Execute query. rows, err := tx.QueryContext(ctx, `SELECT ...`) if err != nil &#123; return nil, n, err &#125; defer rows.Close() // Iterate over rows and deserialize into Dial objects. dials := make([]*wtf.Dial, 0) for rows.Next() &#123; var dial wtf.Dial if rows.Scan(&amp;dial.ID, ...); err != nil &#123; return nil, 0, err &#125; dials = append(dials, &amp;dial) &#125; return dials, n, rows.Err() &#125; 必要的,我们尝试将SQL字段转换为应用程序域对象。wtf.Dial 中有几个有趣的细节。 SQL构建器与手写SQL即使您不使用ORM，也可以使用Squirrel之类的工具来构建SQL语句。我个人并没有用Squirrel，但它看起来可能是一个很好的选择。然而，对于我的大多数查询，我发现手动书写SQL也是足够使用的。 查询条件通常是SQL查询语句变化最多的部分，因此我们将重点讨论查询条件的生成。我们将一系列的过滤字段组合成程序中的一个业务模型(结构体)。我们通过where wtf.DialFilter AND 来构建一个添加数组 // sqlite/dial.go#L295-L311 // List of WHERE clause predicates. Start with an always true predicate // so we have at least one when joining later. where := []string&#123;&quot;1 = 1&quot;&#125; // Bind parameters used by the WHERE clause. var args []interface&#123;&#125;&#123;&#125; // Add predicate for ID if specified on the filter. if v := filter.ID; v != nil &#123; where = append(where, &quot;id = ?&quot;) args = append(args, *v) &#125; 然后我们可以使用strings.Join()构建查询 whereClause := strings.Join(where, &quot; AND &quot;) q := `SELECT ... FROM dials WHERE ` + whereClause 如果我们没有任何过滤字段，那么我们的查询语句就会匹配所有行。如果我们加上我们的ID过滤字段，它将会过滤ID。没有过滤字段的时候,我们添加了 &quot;1 = 1&quot; 额外的语句, 然而SQL语句优化器足够聪明，可以忽略一个始终为真的条件，例如: WHERE 1=1 WHERE 1=1 AND id=？1 = 1 统计行的总数我们的服务接口要求返回用于分页的匹配dial的总数。例如， 接口值返回100个匹配dial中的20个，那么前端想知道匹配dial的总数，这样他们就可以显示共有5页结果. 最简单的方法是先执行带有Limit的查询,获得部分结果，然后重新执行不带Limit的查询。然而，有一些SQL技巧可以让您将这些查询合并到一次查询中. 许多数据库（如SQLite或Postgres）提供了窗口功能。我们可以指定一个窗值口作为查询字段之一，它将忽略 OFFSET LIMIT 注: 窗口功能详细参考该文章 SQL窗口函数 SELECT id, name, COUNT(*) OVER() FROM dials WHERE user_id = ? OFFSET 40 LIMIT 20 // 计算原始查询中的总匹配计数 该字段返回空窗口上查询的总计数。它将为我们查询的每一行返回相同的值，这样我们就可以简单地在每一行的迭代中获取改值。 实现实体查找实体查找这是一个非常常见的任务，因此我发现创建一个单独的函数 FindDials() FindDialByID()非常有用。 // dial.go#L81-L122 package wtf type DialService interface &#123; FindDial(ctx context.Context, id int) (*Dial, error) ... &#125; 接口实现我们的接口实现和前面的接口实现累屎类似，只是我们现在正在 查询单个dial。 sqlite/dial.go#L26-L45 func (s *DialService) FindDialByID(ctx context.Context, id int) (*wtf.Dial, error) &#123; tx, err := s.db.BeginTx(ctx, nil) if err != nil &#123; return nil, err &#125; defer tx.Rollback() // Fetch dial object and attach owner user. dial, err := findDialByID(ctx, tx, id) if err != nil &#123; return nil, err &#125; else if err := attachDialAssociations(ctx, tx, dial); err != nil &#123; return nil, err &#125; return dial, nil &#125; Helper 函数我们的底层实际上包装了函数findDials()，但它改变了语义，由查询多个变单个。 // sqlite/dial.go#L265-L275 // findDialByID is a helper function to retrieve a dial by ID. // Returns ENOTFOUND if dial doesn&#39;t exist. func findDialByID(ctx context.Context, tx *Tx, id int) (*wtf.Dial, error) &#123; dials, _, err := findDials(ctx, tx, wtf.DialFilter&#123;ID: &amp;id&#125;) if err != nil &#123; return nil, err &#125; else if len(dials) == 0 &#123; return nil, &amp;wtf.Error&#123;Code: wtf.ENOTFOUND, Message: &quot;Dial not found.&quot;&#125; &#125; return dials[0], nil &#125; 如果找不到数据，则会返回错误，函数希望给定的拨号存在。在这里，我们将一个空的结果集转换为 “not found” 错误。 您可以在Failure is Your Domain中找到有关使用于应用程序特定类型的详细信息。我将很快编写一个更新版本，其中包括 go1.13 错误包装，但现在大多数概念仍然有效正确。 优化主键查找创建一个单独的函数来优化按ID查找拨dial，而不是重用源代码，这可能会很有用。它允许您跳过片分配并优化查询字段列表，以包含相关的对象数据，例如该表的用户信息。 但是，复制查询代码会导致存在两处相似代码,会增加维护的难度。最好等到在代码中找到需要优化的路径，然后只对它们进行优化。 结论在本文中，我们研究了如何实现业务模型服务接口的读取端，并将高级接口与低级SQL助手函数分开。我们还研究了如何通过与SQL窗口函数集成来优化分页查询。在下一篇文章中，我们将研究如何实现业务模型服务的写接口。 如果不小心的话，SQL很容易渗透到整个应用程序中。通过将数据库代码隔离到单个包中，我们可以确保应用程序代码的其余部分可以干净且独立。 如果您对本文有问题，评论，或建议，请访问GitHub Discussion board,这是一个Github讨论版，使用它可以进行更方便的交流。"},{"title":"编程备忘录","date":"2021-01-25T12:19:47.000Z","path":"2021/01/25/backup-note/","text":"编程中常用的、易忘的配置等记录 VSCode C++ debug 添加第三方动态库配置&#123; &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/example.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;linux&quot;: &#123; // 设置环境变量 &quot;environment&quot;: [&#123;&quot;name&quot;:&quot;LD_LIBRARY_PATH&quot;,&quot;value&quot;:&quot;/brpc/output/lib/:$LD_LIBRARY_PATH&quot;&#125;] &#125;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; 如果您对本文有问题，评论，或建议，请访问GitHub Discussion board,这是一个Github讨论版，使用它可以进行更方便的交流。"},{"title":"[翻译]Packages as layers, not groups","date":"2021-01-25T12:16:37.000Z","path":"2021/01/25/tr-packages-as-layers-not-groups/","text":"原文由 Ben Johnson 发表在 gobeyond，推荐观看原文文章链接 四年前，我写了一篇名为”Standard Package Layout“的文章，试图解决即使是高级Go开发人员最困难的主题之一：package layout(go项目中包的组织)。 但是，大多数开发人员仍在努力用目录的方式组织管理代码。 几乎所有的编程语言都有一种将相关功能分组在一起的机制。 Ruby有gems，Java有packages。 这些语言没有将代码代码分组的标准约定，因为老实说，这并不重要。 一切都取决于个人喜好。 但是，转到Go的开发人员发现他们需要经常关心代码包的组织。 为什么Go软件包与其他语言如此不同？ 这是因为它们不是groups(组)，而是layers(层)。 理解循环引用Go软件包和其他语言之间的主要区别在于Go不允许循环依赖。 程序包A可以依赖程序包B，但是程序包B不能再依赖程序包A。软件包依赖关系只能有一个方向。 因为这个限制，开发人员在两个程序包中共享通用代码时带来了问题。 通常有两种解决方案：将两个程序包合并为一个程序包或引入第三个程序包。 但是，拆分成越来越多的程序包只会使问题继续越扩越大。 最终，相互中将会有大量的软件包，导致结构更加混乱。 标准库的做法进行Go编程时，最有用的技巧之一是在需要指导时查看标准库。 没有代码是完美的，但是Go标准库包含了Go语言创建者许多思想的具体实践。 例如，net/http包建立在net包的抽象之上，而net包又建立在其下面的io层的抽象之上。 这种包结构之所以有效，是因为该开发方式中下层的net不需要依赖上层的net/http包，因此避免了循环引用。 虽然这在标准库中很好实践，但是很难在实际业务项目开发中进行实践。 应用开发中使用层我们将看一个名为WTF Dial的示例应用程序，因此您可以阅读介绍文章以了解更多信息。 在这个应用中，我们有两个逻辑层： 一个 SQLite 数据库 一个 HTTP 服务 我们创建了两个包 sqlite和http。 许多人任务程序包命名与标准库程序包相同的名称是不规范的。 这是一个正确的批评，您可以将其命名为wtfhttp，但是，我们的http包完全封装了net/http包，因此我们永远不会在同一个文件中同时使用它们。 同时，我发现给每个程序包加前缀既乏味又丑陋，所以我不这样做。 常见的包组织方法一种包组织方法的方法是在sqlite包中包含我们的数据类型（例如，User, Dial等）和功能（例如，FindUser()，CreateDial()等）。 我们的http包可能直接依赖于它： 这不是一个坏方法，它适用于简单的应用程序。 但是这里存在一些问题。 首先，我们的数据类型命名为sqlite.User和sqlite.Dial。 这看起来不符合逻辑，因为我们的数据类型属于我们的应用程序，而不是SQLite。 其次，我们的HTTP层现在只能提供来自SQLite的数据。 如果我们需要在两者之间添加缓存层会怎样？ 还是我们如何支持其他数据库，例如Postgres，甚至以JSON形式存储在磁盘上？ 最后，由于没有抽象层，因此我们需要为每个HTTP测试运行一个SQLite数据库，而不能使用mock生成数据。 我通常会尽可能地支持端到端测试(类似于系统测试)，但是在高层中引入单元测试也是非常有效和重要的。而且我们不希望每次测试都需要搭建SQLite组件。 隔离您的业务模型（business domain）第一步需要做的是将我们的业务模型迁移到自己的软件包中。 这也可以称为”application domain(应用程序模型)”。 它是应用程序中专用的数据类型，例如WTF Dial 中的 User, Dial。 在这里，我使用了软件包（wtf）保存我们的业务逻辑。因为它是我们应用程序的名称，并且它是新开发人员打开代码库时首先要看的地方。 其中的数据类型现在更恰当地命名为wtf.User和wtf.Dial。 下面是wtf.Dial类型的一个例子: // dial.go#L14-50 type Dial struct &#123; ID int `json:&quot;id&quot;` // Owner of the dial. Only the owner may delete the dial. UserID int `json:&quot;userID&quot;` User *User `json:&quot;user&quot;` // Human-readable name of the dial. Name string `json:&quot;name&quot;` // Code used to share the dial with other users. // It allows the creation of a shareable link without // explicitly inviting users. InviteCode string `json:&quot;inviteCode,omitempty&quot;` // Aggregate WTF level for the dial. Value int `json:&quot;value&quot;` // Timestamps for dial creation &amp; last update. CreatedAt time.Time `json:&quot;createdAt&quot;` UpdatedAt time.Time `json:&quot;updatedAt&quot;` // List of associated members and their contributing WTF level. // This is only set when returning a single dial. Memberships []*DialMembership `json:&quot;memberships,omitempty&quot;` &#125; 在此代码中，没有引用任何实现细节，仅是原始数据类型和time.Time。 为了方便起见，添加了JSON标签。 通过接口删除依赖项我们的应用程序结构现在看起来更好，但是HTTP依赖SQLite仍然很奇怪。 我们的HTTP服务器希望从基础数据存储中获取数据，它并不特别关心是否为 SQLite。 为了解决这个问题，我们为业务模型域中的服务创建接口。 这些服务通常是创建/读取/更新/删除（CRUD），但可以扩展到其他操作。 // dial.go#L81-L122 // DialService represents a service for managing dials. type DialService interface &#123; // Retrieves a single dial by ID along with associated memberships. Only // the dial owner &amp; members can see a dial. Returns ENOTFOUND if dial does // not exist or user does not have permission to view it. FindDialByID(ctx context.Context, id int) (*Dial, error) // Retrieves a list of dials based on a filter. Only returns dials that // the user owns or is a member of. Also returns a count of total matching // dials which may different from the number of returned dials if the // &quot;Limit&quot; field is set. FindDials(ctx context.Context, filter DialFilter) ([]*Dial, int, error) // Creates a new dial and assigns the current user as the owner. // The owner will automatically be added as a member of the new dial. CreateDial(ctx context.Context, dial *Dial) error // Updates an existing dial by ID. Only the dial owner can update a dial. // Returns the new dial state even if there was an error during update. // // Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user // is not the dial owner. UpdateDial(ctx context.Context, id int, upd DialUpdate) (*Dial, error) // Permanently removes a dial by ID. Only the dial owner may delete a dial. // Returns ENOTFOUND if dial does not exist. Returns EUNAUTHORIZED if user // is not the dial owner. DeleteDial(ctx context.Context, id int) error &#125; 现在，我们的业务模型包（wtf）不仅指定了数据结构，而且还指定了接口规范，以说明我们的各层如何相互通信。 这使我们的程序包层次结构变得平坦，因此所有程序包现在都依赖于业务模型程序包。 这使我们可以打破包之间的直接依赖关系，并引入替代实现，例如mock。 重新包装packagesRepackaging packages 打破软件包之间的依赖关系使我们可以灵活地使用代码。 对于我们的应用程序二进制文件wtfd，我们仍然希望http依赖于sqlite（请参阅wtf/main.go），但是对于测试，我们可以更改http依赖于我们的新mock包（请参阅http/server_test.go）： 对于我们的小型Web应用程序WTF Dial来说，这可能是过度设计，但是随着我们代码库的增长，它变得越来越重要。 结论包是Go中强大的工具，但如果将它们视为组而不是图层，则是导致很多困惑。了解了应用程序的逻辑层之后，您可以提取业务域的数据类型和接口协定，并将它们移至应用程序模型包中，以用作所有子包的通用域语言。 随着时间的推移，对于扩展应用程序，定义此模型包至关重要。 如果您对本文有问题，评论，或建议，请访问GitHub Discussion board,这是一个Github讨论版，使用它可以进行更方便的交流。"},{"title":"[翻译]Common CRUD Design in Go","date":"2021-01-24T12:38:13.000Z","path":"2021/01/24/tr-common-crud-design-in-go/","text":"原文由 Ben Johnson 发表在 gobeyond，推荐观看原文文章链接 增删改查（CRUD）是一个技术产品的基础部分，做过应用开发的人应该很熟悉它。 开发CRUD应用时，大多数编程语言会有框架提供一个固定的开发架构，例如PHP的Yii2、Java的SSH。但是总所周知Go社区是反框架的。因此，我们需要设计自己的CRUD架构。 在一年的Go应用开发经验后，我发现了一套通用的CRUD设计模式，能满足大多数不同的项目的要求。我将以开发 WTF Dial 项目为例进行说明。 项目的详细介绍参考链接。 译者：WTF Dial(which they feel) 项目提供一个界面，每个成员可输入对当前团队的糟糕程度(f-cked)。 接口设计在 WTF Dial应用中，我们采用面向接口开发，定义软件提供的服务为一个接口。通过接口提供服务，我们底层可以使用不同的实现方法。在dial.go中，我们定义了如下DialService 接口。 // dial.go#L81-L122 type DialService interface &#123; FindDialByID(ctx context.Context, id int) (*Dial, error) FindDials(ctx context.Context, filter DialFilter) ([]*Dial, int, error) CreateDial(ctx context.Context, dial *Dial) error UpdateDial(ctx context.Context, id int, upd DialUpdate) (*Dial, error) DeleteDial(ctx context.Context, id int) error &#125; 这个结构是我在应用程序中使用的几乎所有实体。它提供了一个简单的结构，但在大多数情况下它都足够灵活。 事务边界我将我的服务定义视为一个黑盒子。因此，我很少向应用程序的其他部分公开事务等内部细节。虽然让服务的调用者组成单独的事务调用可能很诱人，但很少有必要这样做，而且通常会使应用程序复杂化。 译者注：我的理解为将一个服务接口看作一个事务调用，复杂的调用也组织成一个事务。 通过 Context 验证安全在WTF Dial中，当请求到来时，将对user进行身份验证。然后验证通过过的user 将被添加到NewContextWithUser()函数创建 context.Context中。这意味着我们的服务中的任何函数都可以通过ctx参数访问当前 user。 出于几个原因，强制授权被内置到服务实现中。首先，它确保验证在可能的最低级别执行，而不是委托给更高级别的抽象。当我们可以将安全检查直接嵌入到SQL查询中时，我们不太可能忘记安全检查。其次，将这些限制推到数据库层会更有效，因为它限制查询和返回的数据。 下面是sqlite.findDials()函数内的一个安全验证的示例，我们将限制用户仅能查询自己所属组的 dial_id: // sqlite/dial.go#L306-L310 userID := wtf.UserIDFromContext(ctx) where = append(where, `id IN (SELECT dial_id FROM dial_memberships dm WHERE dm.user_id = ?)`) args = append(args, userID) 查找单个对象根据主键查找对象是您将遇到的最常见任务之一。这里我们定义了一个根据其id获取wtf.Dial的函数: FindDialByID(ctx context.Context, id int) (*Dial, error) 这个函数定义看似简单，但有重要的问题需要确定。如果ID不存在怎么办? 这种情况应该定义为一种 error 还是 *Dial为空？ 不要返回两个 nil我看到的一个常见做法是，如果ID无法找到，开发人员将返回 nil Dial 和 nil error。然而，在这种情况下，用户希望调用函数得到一个特定的 Dial，而不是一个nil，因此ID未发现将是一个err。 在实践中，函数的调用者将执行一个简单的 err != nil 检查是否错误发生，但很容易忘记检查 nil Dial。这将导致您的程序 panic。 // Try to fetch the dial by ID but it doesn&#39;t exist. dial, err := FindDialByID(ctx, 100) if err != nil &#123; return err &#125; // 未检查 dial 是否为空 // 译者注：保证返回的数据是可用的，否者都返回一个error // Oops! Panic here because dial is nil. fmt.Printf(&quot;WTF Level: %d&quot;, dial.Value) 确保返回一个对象或一个错误，两者不能同时为nil. 选择返回的数据当返回我们的Dial对象时，调用者通常也需要其他的附加信息。Dial的用户是谁? 谁是 Dial 的其他成员?(即数据库中的一对一、一对多、多对多关系。例如学生和班级、老师和学生、老师和班级)。我们的数据是一个相互关联的图，所以我们需要定义返回的具体数据。 我们可以允许调用者使用额外的标记参数告诉服务需要那些参数，但这会增加应用程序的复杂性。相对来说，后台根据业务直接返回包含有用的相关数据更加容易。虽然这会招致额外的数据库调用或增加网络带宽，但这通常是一个很好的权衡，我们可以根据需要优化返回情况。 译者注：比如返回一篇博文时，通常会标签会经常使用，我们可以直接一起返回。但是评论可能很少使用，我们可以提供单独接口。 这里有个判定方法：我通常返回与主对象有父关系的相关数据。在Dial的例子中，它有一个我要附加的用户父对象。调用者几乎总是需要这些关系，因为它们为对象提供了上下文。 而返回子关系的数据会很容易地造成返回数据过多。但是。如果我知道子对象的数量是有限的，并且在查看父对象时它们几乎总是被获取，那么我就会包括子关系。在 Dial 的情况下，我们可以包括Dial的成员列表，因为这通常是有用的，我们永远不会有超过少数的成员。另一个很好的例子是返回一组带有电子商务订单的订单项。 译者注：更简单理解，如果数据存在经常被使用的一对一关系，可以一起返回。如果存在一对多则要仔细考虑是否经常使用到该关联数据。 查询多个数据我们的下一个函数提供了一种通过各种过滤选项来搜索Dial数据的方法。获取一个Dial列表听起来类似于获取单个Dial，但有一些重要的区别。 FindDials(ctx context.Context, filter DialFilter) ([]*Dial, int, error) *Dial 和 error 同时返回nil是可以的。与FindDialByID()不同，它可以不返回Dial 并返回nil error(即没有错误发生，数据也为空)。调用者可能不知道是否有任何匹配的Dial(这就是他们搜索的原因)，所以不匹配任何Dial不是一个错误条件。 我们也不需要像查找单个Dial时那样担心panic，因为我们返回的是一个切片。切片上的大多数操作(len()或for in)都可以在nil slice上正常工作。 // Search for a list of all dials. dials, _, err := FindDials(ctx, DialFilter&#123;&#125;) if err != nil &#123; return err &#125; // 译者注：空切片除了取值大部分操作都不会发生panic，因此对切片取值操作前必须判断是否为空 // No panic this time. A nil slice of dials is ok. fmt.Printf(&quot;You have %d dials.&quot;, len(dials)) // Returning a nil list and a nil error will not cause a panic 过滤结果在这个函数中，我们传入一个filter对象，而不是多个过滤参数。这允许我们添加额外的过滤器，而不会破坏未来的API兼容性。 // dial.go#L124-L133 // DialFilter represents a filter used by FindDials(). type DialFilter struct &#123; // Filtering fields. ID *int `json:&quot;id&quot;` InviteCode *string `json:&quot;inviteCode&quot;` // 限制结果的一个子集，通常用在分页中 // Restrict to subset of range. Offset int `json:&quot;offset&quot;` Limit int `json:&quot;limit&quot;` &#125; 我们在过滤器结构中使用指针，这样我们就可以选择性地添加过滤属性(不需要过滤，置为 nil 即可)。我们设置的每个字段将进一步过滤查找返回的结果。 结果切片 &amp; 结果统计上面 DialFilter 对象中的 Offset 和 Limit 字段可用于返回结果的子集，类似于 SQL 中的 Offset 和 Limit 子句。通常用作分页。 即使我们限制了返回的 Dial 数量，但是，我们仍需要知道匹配的 Dial 的总数。例如，分页中知道总数才能确定分多少页。为此，除了返回[]*Dial外，我们还返回一个int值，表示结果总数。 一些数据库允许我们在一个SQL查询中使用COUNT(*) OVER() 计算查询到数据总量。例如，如果我们搜索用户ID为100的Dial，并且我们将搜索限制为20条记录，我们仍然可以得到查询到的总数: -- 同时返回20 dials 和 dials 总量 SELECT id, name, COUNT(*) OVER() FROM dials WHERE user_id = 100 ORDER BY id LIMIT 20 我们可以遍历得到结果集，并获得数据的总数，如下所示: var dials []*Dial // n 保存 总数 var n int // rows 为 GO SQL查询返回的结果集 for rows.Next() &#123; var dial Dial if rows.Scan(&amp;dial.ID, &amp;dial.UserID, &amp;n); err != nil &#123; return err &#125; dials = append(dials, &amp;dial) &#125; // 查询集每一行都会返回n，但是值都是一样的。 排序结果集对于排序，不能允许用户按数据库中的任何列排序。因为大多数列不会被索引，所以查询会很慢。相反，我建议将一组固定的值映射到数据库中的列。例如，“name_asc”可以映射到 ORDER BY name ASC子句。 具体例子可见 WTF Dial中搜索会员后按修改时间排序 // sqlite/dial_membership.go#L164-L172 var sortBy string // filter 为上文的过滤结构体 switch filter.SortBy &#123; case &quot;updated_at_desc&quot;: sortBy = &quot;dm.updated_at DESC&quot; default: sortBy = `dm.ID ASC` &#125; 在这个代码片段中，我们检查 filter.SortBy 字段是否设置为预定义的排序顺序(“updated_at_desc”)。如果是，我们将其转换为一个SQL代码片段。否则，我们使用默认排序情况。可以保证只使用我们定义好的排序规则，用户不能自定义其他列上的排序，保证查找数据的高效。 新建DialTo create a new user in our application, we have the following function: 为了在我们的应用程序中创建一个Dial，我们使用以下函数: CreateDial(ctx context.Context, dial *Dial) error 这里我们传入我们想要创建的Dial对象。我们需要将新的拨号ID传回给调用者，以便更新主键dial.ID和由服务实现生成的任何其他字段(例如创建日期)。 如果您不想更新原始的Dial对象，也可以从函数返回一个单独的Dial对象。但是，我发现这种方法在实践中比较麻烦。 译者注：这里的含义是传入 CreateDial 的 Dial 对象的 ID 和 UpdatedAt 和 CreatedAt 等都为空。插入SQL执行后，获得对应的属性赋值给传入的Dial原对象。在业务层就能直接使用该Dial,而不用新返回一个Dial了。 以事务的方式构建对象图因为我们将事务边界限制为函数调用(一个函数调用为一个事务)，所以应该允许创建适当的嵌套对象。例如，我们可以接受附加到将在同一个事务中创建的Dial上的DialMembership对象列表。 svc.CreateDial(ctx, &amp;wtf.Dial&#123; UserID: 100, Name: &quot;My Dial&quot;, Memberships: []*wtf.DialMembership&#123; &#123; User: &amp;wtf.User&#123;Email:&quot;susy@que.com&quot;&#125;, Value: 50, &#125;, &#123; User: &amp;wtf.User&#123;Email:&quot;john@doe.com&quot;&#125;, Value: 50, &#125;, &#125;, &#125;) // 在一个函数调用中创建包含多个 members 的一个 dial // Creating a dial and with a multiple members in one call 更新Dial对于更新已存在的用户，我们有以下函数: UpdateDial(ctx context.Context, id int, upd DialUpdate) (*Dial, error) 这个函数使用upd中设置的字段值更新一个给定ID的Dial。并返回新更新的Dial。我们的更新类型为DialUpdate，其中包含我们允许更新的字段(一般来说,只有部分字段允许更新: // DialUpdate represents a set of fields to update on a dial. type DialUpdate struct &#123; Name *string `json:&quot;name&quot;` &#125; 注意，Name字段是指针类型表明它是可选的。如果它没有被设置，那么它就不会被更新。我们的DialUpdate类型很简单，但是如果我们希望允许用户将Dial重新分配给其他人，我们可以想象添加一个UserID字段。这使得我们可以避免向我们的服务添加新接口ReassignDial()。 返回错误的表盘与许多Go函数不同，UpdateDial()总是返回一个Dial对象，即使发生了错误。这是很有用的，因为用户通常希望看到如果出现验证错误，他们试图更新Dial的状态。对于基于web的应用程序来说每个HTTP请求都是无状态的，返回Dial这一点尤其重要。 批量更新id字段被有意地从DialUpdate类型中分离出来，这样我们也可以允许批量更新。例如，我们可以构建一个名为UpdateDials()的函数: UpdateDials(ctx context.Context, ids []int, upd DialUpdate) ([]*Dial, error) 通过将函数更改为接受id列表，我们可以将其应用于所有id。同时，我们需要返回一个更新后的Dial列表。 删除 Dial老实说，关于删除的事没什么好说的。我们有一个简单的按主键删除的函数: DeleteDial(ctx context.Context, id int) error 我们可以通过提供一个 id 切片来将其展开为一个批量删除: DeleteDials(ctx context.Context, id []int) error 请确保执行授权限制，以确保用户不能删除其他用户的Dial。 结论优化CRUD应用程序开发至关重要，因为它占据了大多数应用程序代码的大部分。我们已经看了一个构建Go CRUD函数的基本框架，它在灵活性和简单性之间取得了平衡。您需要调整这个框架，因为每个应用程序都有自己独特的需求，但希望它从一个坚实的基础开始。 如果您有WTF Dial问题，评论，或建议，请访问WTF Dial GitHub Discussion board。 如果您对本文有问题，评论，或建议，请访问GitHub Discussion board,这是一个Github讨论版，使用它可以进行更方便的交流。"}]